// src/debug_view.rs

use crate::cpu::CpuRegisters;
use crate::apu::ApuState;
use crate::ppu::Ppu;
use crate::timer::Timer;

pub const DEBUG_WIDTH: usize = 480;
pub const DEBUG_HEIGHT: usize = 320;
const CHAR_WIDTH: usize = 8;
const CHAR_HEIGHT: usize = 8;

// --- カラーテーマ ---
const COLOR_BG: u32 = 0xFF0A0F1A;
const COLOR_GRID_DARK: u32 = 0xFF101828;
const COLOR_GRID_LIGHT: u32 = 0xFF1A2A47;
const COLOR_TITLE: u32 = 0xFF00FFFF;
const COLOR_LABEL: u32 = 0xFF4A90E2;
const COLOR_VALUE: u32 = 0xFFE8D577;
const WAVEFORM_COLORS: [u32; 4] = [0xFF7ED321, 0xFFF5A623, 0xFFF8E71C, 0xFFBD10E0];
// ★★★ 修正点: 未使用の定数を削除 ★★★
// const COLOR_SEPARATOR: u32 = 0xFF4A4A4A;

// FONT_DATAは長いため省略 (変更なし)
static FONT_DATA: [[u8; CHAR_HEIGHT]; 95] = [
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // ' '
    [0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00], // '!'
    [0x24, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00], // '"'
    [0x24, 0x7E, 0x24, 0x7E, 0x24, 0x00, 0x00, 0x00], // '#'
    [0x24, 0x2B, 0x6A, 0x2A, 0x2A, 0x52, 0x00, 0x00], // '$'
    [0x62, 0x64, 0x08, 0x13, 0x26, 0x46, 0x62, 0x00], // '%'
    [0x3C, 0x66, 0x3C, 0x76, 0x66, 0x3C, 0x00, 0x00], // '&'
    [0x18, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00], // '''
    [0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00], // '('
    [0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00], // ')'
    [0x00, 0x42, 0x24, 0x18, 0x24, 0x42, 0x00, 0x00], // '*'
    [0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00], // '+'
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30], // ','
    [0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00], // '-'
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00], // '.'
    [0x00, 0x02, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00], // '/'
    [0x3C, 0x66, 0x6E, 0x76, 0x66, 0x3C, 0x00, 0x00], // '0'
    [0x18, 0x38, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00], // '1'
    [0x3C, 0x66, 0x06, 0x1C, 0x30, 0x7E, 0x00, 0x00], // '2'
    [0x3C, 0x66, 0x06, 0x3C, 0x06, 0x66, 0x3C, 0x00], // '3'
    [0x1E, 0x36, 0x66, 0x7E, 0x06, 0x06, 0x00, 0x00], // '4'
    [0x7E, 0x60, 0x7C, 0x06, 0x66, 0x3C, 0x00, 0x00], // '5'
    [0x3C, 0x60, 0x60, 0x7C, 0x66, 0x3C, 0x00, 0x00], // '6'
    [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x00, 0x00], // '7'
    [0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00], // '8'
    [0x3C, 0x66, 0x66, 0x3E, 0x06, 0x0C, 0x3C, 0x00], // '9'
    [0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00], // ':'
    [0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30, 0x00], // ';'
    [0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00], // '<'
    [0x00, 0x3C, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x00], // '='
    [0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00], // '>'
    [0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00], // '?'
    [0x3C, 0x66, 0x7E, 0x7E, 0x7E, 0x60, 0x3C, 0x00], // '@'
    [0x18, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00], // 'A'
    [0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00], // 'B'
    [0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00], // 'C'
    [0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x00], // 'D'
    [0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E, 0x00], // 'E'
    [0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x00], // 'F'
    [0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00], // 'G'
    [0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00], // 'H'
    [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00], // 'I'
    [0x0C, 0x06, 0x06, 0x06, 0x06, 0x66, 0x3C, 0x00], // 'J'
    [0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00], // 'K'
    [0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00], // 'L'
    [0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00], // 'M'
    [0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00], // 'N'
    [0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00], // 'O'
    [0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00], // 'P'
    [0x3C, 0x66, 0x66, 0x66, 0x6A, 0x6C, 0x36, 0x00], // 'Q'
    [0x7C, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x00], // 'R'
    [0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00], // 'S'
    [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00], // 'T'
    [0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00], // 'U'
    [0x66, 0x66, 0x66, 0x3C, 0x3C, 0x18, 0x18, 0x00], // 'V'
    [0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00], // 'W'
    [0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00], // 'X'
    [0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00], // 'Y'
    [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00], // 'Z'
    [0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00], // '['
    [0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x00], // '\'
    [0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00], // ']'
    [0x00, 0x18, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00], // '^'
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF], // '_'
    [0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00], // '`'
    [0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00], // 'a'
    [0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00], // 'b'
    [0x00, 0x00, 0x3C, 0x66, 0x60, 0x66, 0x3C, 0x00], // 'c'
    [0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00], // 'd'
    [0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00], // 'e'
    [0x1C, 0x36, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x00], // 'f'
    [0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x7C], // 'g'
    [0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00], // 'h'
    [0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00], // 'i'
    [0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38], // 'j'
    [0x60, 0x60, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66], // 'k'
    [0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00], // 'l'
    [0x00, 0x00, 0x66, 0xFF, 0xFF, 0x6B, 0x6B, 0x00], // 'm'
    [0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00], // 'n'
    [0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00], // 'o'
    [0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60], // 'p'
    [0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x0C, 0x0E], // 'q'
    [0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x00], // 'r'
    [0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00], // 's'
    [0x10, 0x10, 0x7C, 0x10, 0x10, 0x12, 0x0C, 0x00], // 't'
    [0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00], // 'u'
    [0x00, 0x00, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x00], // 'v'
    [0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00], // 'w'
    [0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00], // 'x'
    [0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x3C], // 'y'
    [0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00], // 'z'
    [0x0E, 0x18, 0x18, 0x30, 0x18, 0x18, 0x0E, 0x00], // '{'
    [0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00], // '|'
    [0x70, 0x18, 0x18, 0x0C, 0x18, 0x18, 0x70, 0x00], // '}'
    [0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00], // '~'
];


fn draw_char(buffer: &mut [u32], char_to_draw: char, start_x: usize, start_y: usize, color: u32) {
    let char_code = char_to_draw as usize;
    if !(32..=126).contains(&char_code) { return; }
    let glyph = FONT_DATA[char_code - 32];
    for y in 0..CHAR_HEIGHT {
        let row = glyph[y];
        for x in 0..CHAR_WIDTH {
            if (row >> (7 - x)) & 1 == 1 {
                let px = start_x + x;
                let py = start_y + y;
                if px < DEBUG_WIDTH && py < DEBUG_HEIGHT {
                    buffer[py * DEBUG_WIDTH + px] = color;
                }
            }
        }
    }
}

fn draw_text(buffer: &mut [u32], text: &str, mut x: usize, y: usize, color: u32) {
    for char_to_draw in text.chars() {
        draw_char(buffer, char_to_draw, x, y, color);
        x += CHAR_WIDTH;
    }
}

fn draw_background(buffer: &mut [u32]) {
    for y in 0..DEBUG_HEIGHT {
        for x in 0..DEBUG_WIDTH {
            buffer[y * DEBUG_WIDTH + x] = if (x % 16 == 0) || (y % 16 == 0) { COLOR_GRID_DARK } else { COLOR_BG };
        }
    }
}

fn draw_waveform(buffer: &mut [u32], x: usize, y: usize, w: usize, h: usize, waveform: &[f32], color: u32, is_periodic: bool) {
    let h_mid = y + h / 2;
    for i in 1..w { buffer[h_mid * DEBUG_WIDTH + x + i] = COLOR_GRID_LIGHT; }

    // ★★★ 修正点: `samples_to_draw` の初期化方法を変更 ★★★
    const TRIGGER_LEVEL: f32 = 0.0;
    let samples_to_draw: &[f32] = if is_periodic && waveform.len() > w {
        let mut trigger_offset: Option<usize> = None;
        for i in (0..waveform.len() - 1).rev() {
            if waveform[i] <= TRIGGER_LEVEL && waveform[i+1] > TRIGGER_LEVEL {
                if waveform.len() - (i + 1) >= w {
                    trigger_offset = Some(i + 1);
                    break;
                }
            }
        }
        
        if let Some(offset) = trigger_offset {
            &waveform[offset..offset + w]
        } else {
            &waveform[waveform.len() - w..]
        }
    } else {
        &waveform[waveform.len().saturating_sub(w)..]
    };

    let mut last_py = h_mid;
    for (i, sample) in samples_to_draw.iter().take(w).enumerate() {
        let py = (h_mid as f32 - (sample * (h / 2) as f32 * 0.9)) as usize;
        let py = py.clamp(y + 1, y + h - 1);
        
        let px = x + i;
        
        let min_y = std::cmp::min(last_py, py);
        let max_y = std::cmp::max(last_py, py);

        for iy in min_y..=max_y { buffer[iy * DEBUG_WIDTH + px] = color; }
        last_py = py;
    }
}

fn draw_oam_viewer(buffer: &mut [u32], ppu: &Ppu, start_x: usize, start_y: usize) {
    const SCALE: usize = 2;
    const PADDING: usize = 4;
    const GRID_COLS: usize = 8;

    let colors = &ppu.get_colors();
    draw_text(buffer, "[OAM SPRITES (2x SCALE)]", start_x, start_y, COLOR_TITLE);

    let sprite_height = if (ppu.lcdc & 0b100) != 0 { 16 } else { 8 };

    for i in 0..40 {
        let grid_x = i % GRID_COLS;
        let grid_y = i / GRID_COLS;
        let draw_x = start_x + grid_x * (8 * SCALE + PADDING);
        let draw_y = start_y + 20 + grid_y * (sprite_height as usize * SCALE + PADDING);

        let oam_addr = i * 4;
        let tile_index = ppu.oam[oam_addr + 2];
        let attributes = ppu.oam[oam_addr + 3];
        
        let x_flip = (attributes & 0b00100000) != 0;
        let y_flip = (attributes & 0b01000000) != 0;
        let palette_data = if (attributes & 0b00010000) != 0 { ppu.obp1 } else { ppu.obp0 };

        for h in 0..sprite_height {
            let mut current_tile_index = tile_index;
            if sprite_height == 16 {
                current_tile_index = if h < 8 { tile_index & 0xFE } else { tile_index | 0x01 };
            }
            let tile_y = if y_flip { sprite_height - 1 - h } else { h } % 8;
            
            let tile_addr = 0x8000u16 + (current_tile_index as u16 * 16) + (tile_y as u16 * 2);
            let byte1 = ppu.vram.get(tile_addr as usize - 0x8000).copied().unwrap_or(0);
            let byte2 = ppu.vram.get(tile_addr as usize - 0x8000 + 1).copied().unwrap_or(0);

            for tile_x in 0..8 {
                let bit_pos = if x_flip { tile_x } else { 7 - tile_x };
                let color_id = (((byte2 >> bit_pos) & 1) << 1) | ((byte1 >> bit_pos) & 1);

                if color_id == 0 { continue; }

                let shade_index = (palette_data >> (color_id * 2)) & 0b11;
                let color = colors[shade_index as usize];
                
                for sy in 0..SCALE {
                    for sx in 0..SCALE {
                        let px = draw_x + (tile_x as usize * SCALE) + sx;
                        let py = draw_y + (h as usize * SCALE) + sy;
                        if px < DEBUG_WIDTH && py < DEBUG_HEIGHT {
                            buffer[py * DEBUG_WIDTH + px] = color;
                        }
                    }
                }
            }
        }
    }
}

pub fn draw(
    buffer: &mut [u32],
    cpu_regs: CpuRegisters,
    ime: bool,
    apu_state: &ApuState,
    ppu: &Ppu,
    timer: &Timer,
    interrupt_enable: u8,
    interrupt_flag: u8,
    fps: f64,
    waveforms: &[Vec<f32>; 4],
) {
    draw_background(buffer);

    let left_panel_x = 10;
    let right_panel_x = 260;
    let mut current_y = 10;

    // --- 左パネル (テキスト情報) ---
    draw_text(buffer, &format!("[SYS] FPS: {:.1}", fps), left_panel_x, current_y, COLOR_VALUE);
    current_y += 15;
    let flags = format!("F:{}{}{}{} IME:{}", if cpu_regs.f_z() {'Z'} else {'-'}, if cpu_regs.f_n() {'N'} else {'-'}, if cpu_regs.f_h() {'H'} else {'-'}, if cpu_regs.f_c() {'C'} else {'-'}, ime as u8);
    draw_text(buffer, &flags, left_panel_x, current_y, COLOR_VALUE);
    current_y += 15;
    
    draw_text(buffer, "[CPU]", left_panel_x, current_y, COLOR_TITLE);
    current_y += 12;
    draw_text(buffer, &format!("AF:{:04X} BC:{:04X}", cpu_regs.af(), cpu_regs.bc()), left_panel_x, current_y, COLOR_LABEL);
    current_y += 10;
    draw_text(buffer, &format!("DE:{:04X} HL:{:04X}", cpu_regs.de(), cpu_regs.hl()), left_panel_x, current_y, COLOR_LABEL);
    current_y += 10;
    draw_text(buffer, &format!("SP:{:04X} PC:{:04X}", cpu_regs.sp, cpu_regs.pc), left_panel_x, current_y, COLOR_LABEL);
    current_y += 15;

    draw_text(buffer, "[PPU|TMR|INT]", left_panel_x, current_y, COLOR_TITLE);
    current_y += 12;
    draw_text(buffer, &format!("LCDC:{:02X} STAT:{:02X}", ppu.lcdc, ppu.stat), left_panel_x, current_y, COLOR_LABEL);
    current_y += 10;
    draw_text(buffer, &format!("SCY:{:02X} SCX:{:02X}", ppu.scy, ppu.scx), left_panel_x, current_y, COLOR_LABEL);
    current_y += 10;
    draw_text(buffer, &format!("LY:{:02X} LYC:{:02X}", ppu.ly, ppu.lyc), left_panel_x, current_y, COLOR_LABEL);
    current_y += 10;
    draw_text(buffer, &format!("DIV:{:02X} TIMA:{:02X}", timer.read_div(), timer.tima), left_panel_x, current_y, COLOR_LABEL);
    current_y += 10;
    draw_text(buffer, &format!("IE:{:02X} IF:{:02X}", interrupt_enable, interrupt_flag), left_panel_x, current_y, COLOR_VALUE);
    current_y += 15;

    draw_oam_viewer(buffer, ppu, left_panel_x, current_y);

    // --- 右パネル (グラフィカル情報) ---
    current_y = 10;
    draw_text(buffer, "[APU OSCILLOSCOPE]", right_panel_x, current_y, COLOR_TITLE);
    current_y += 15;
    
    let scope_w = DEBUG_WIDTH - right_panel_x - 10;
    let scope_h = 45;
    let scope_titles = ["PULSE 1", "PULSE 2", "WAVE", "NOISE"];

    for i in 0..4 {
        let is_periodic = i < 3;
        draw_text(buffer, &format!("[{}]", scope_titles[i]), right_panel_x, current_y, WAVEFORM_COLORS[i]);
        draw_waveform(buffer, right_panel_x, current_y + 10, scope_w, scope_h, &waveforms[i], WAVEFORM_COLORS[i], is_periodic);
        current_y += scope_h + 20;
    }
    
    draw_text(buffer, "[WAVE RAM]", right_panel_x, current_y, COLOR_TITLE);
    current_y += 15;
    let wave_ram_str: Vec<String> = apu_state.wave_ram.iter().map(|b| format!("{:02X}", b)).collect();
    draw_text(buffer, &wave_ram_str[0..8].join(" "), right_panel_x, current_y, COLOR_VALUE);
    current_y += 10;
    draw_text(buffer, &wave_ram_str[8..16].join(" "), right_panel_x, current_y, COLOR_VALUE);
}